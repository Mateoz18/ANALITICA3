# -*- coding: utf-8 -*-
"""Modelo_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rUqszKIMXGXHOJLg81KgYuECAQvznAfT
"""

import numpy as np
import pandas as pd
import sqlite3 as sql
import plotly.graph_objs as go ### para gráficos
import plotly.express as px
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from ipywidgets import interact ## para análisis interactivo
from sklearn import neighbors ### basado en contenido un solo producto consumido
import joblib
from sklearn.neighbors import NearestNeighbors

# Conexion con Drive
from google.colab import drive
drive.mount('/content/drive')

# Cambio de directorio de Trabajo
import os
import sys
path = '/content/drive/MyDrive/Mod2/ANALITICA3'
os.chdir(path)
sys.path.append(path)

import sqlite3 as sql
import pandas as pd
import numpy as np

conn=sql.connect('/content/drive/MyDrive/Mod2/ANALITICA3/data/db_movies')
cur=conn.cursor() ###para funciones que ejecutan sql en base de datos

### para verificar las tablas que hay disponibles
cur.execute("SELECT name FROM sqlite_master where type='table' ")
cur.fetchall()

# Cargas la tabla que ya contiene los datos procesados
tabla_completa = pd.read_sql_query("SELECT * FROM full_ratings", conn)

tabla_completa

"""
**Recomendaciones basado en popularidad**"""

# Crear tabla de popularidad de películas
movie_popularity = pd.read_sql('''
    SELECT
        movie_title,
        COUNT(*) AS num_ratings,
        ROUND(AVG(movie_rating), 2) AS avg_rating
    FROM full_ratings
    GROUP BY movie_title
    HAVING num_ratings BETWEEN 50 AND 500
''', conn)

# Ordenar por promedio de calificación y número de votos
popular_movies = movie_popularity.sort_values(['avg_rating', 'num_ratings'], ascending=False)

# Mostrar top 10 películas recomendadas por popularidad
popular_movies.head(10)

""" **Fórmula del score ponderado**"""

# Promedio global de todas las calificaciones
C = pd.read_sql('SELECT AVG(movie_rating) FROM full_ratings', conn).iloc[0, 0]

movie_popularity2 = pd.read_sql('''
    SELECT
        movie_title AS title,
        movie_id,
        COUNT(*) AS num_ratings,
        ROUND(AVG(movie_rating), 2) AS avg_rating
    FROM full_ratings
    GROUP BY movie_id, movie_title
''', conn)

# Percentil 75 de la cantidad de votos
m = movie_popularity2['num_ratings'].quantile(0.75)

# Calcular el score ponderado
movie_popularity2['weighted_score'] = (
    (movie_popularity2['num_ratings'] / (movie_popularity2['num_ratings'] + m)) * movie_popularity2['avg_rating'] +
    (m / (movie_popularity2['num_ratings'] + m)) * C
)

# Ordenar por el score ponderado
movie_popularity_sorted = movie_popularity2.sort_values('weighted_score', ascending=False)

# Mostrar las top 10 películas recomendadas
movie_popularity_sorted[['title', 'weighted_score', 'num_ratings', 'avg_rating']].head(10)

# Consulta para obtener las mejores calificaciones por año de publicación
best_rated_by_year = pd.read_sql("""
    SELECT
        movie_year,
        movie_title,
        AVG(CASE WHEN movie_rating = 0 THEN NULL ELSE movie_rating END) AS avg_rat,
        COUNT(CASE WHEN movie_rating = 0 THEN NULL ELSE movie_rating END) AS rat_numb,
        COUNT(*) AS read_num
    FROM full_ratings
    WHERE movie_rating <> 0
    GROUP BY movie_year, movie_title
    ORDER BY movie_year DESC, avg_rat DESC
    LIMIT 10
""", conn)

# Mostrar los resultados
best_rated_by_year

"""**tabla de popularidad por género**"""

query = '''
WITH exploded_genres AS (
    SELECT
        movie_title,
        movie_rating,
        TRIM(je.value) AS genre
    FROM full_ratings,
         json_each('["' || REPLACE(movie_genres, '|', '","') || '"]') AS je
)
SELECT
    genre,
    movie_title,
    COUNT(*) AS num_ratings,
    ROUND(AVG(movie_rating), 2) AS avg_rating
FROM exploded_genres
WHERE movie_rating <> 0
GROUP BY genre, movie_title
HAVING num_ratings >= 10
ORDER BY genre, avg_rating DESC
'''

genre_popularity = pd.read_sql(query, conn)

# Mostrar las top 5 películas por cada género
genre_popularity.groupby('genre').head(5)

from ipywidgets import interact, Dropdown, IntSlider

# Lista de géneros más opción "Todos"
generos = ['Todos'] + sorted(genre_popularity['genre'].unique().tolist())

def recomendaciones_interactivas(tipo, min_ratings=50, year=2000, genre='Todos'):
    if tipo == 'Popularidad':
        df = movie_popularity[movie_popularity['num_ratings'] >= min_ratings]
        df = df.sort_values(['avg_rating', 'num_ratings'], ascending=False)
        return df[['movie_title', 'avg_rating', 'num_ratings']].head(10)

    elif tipo == 'Por año':
        df = tabla_completa[(tabla_completa['movie_year'] == year) &
                            (tabla_completa['movie_rating'] >= 0)]
        df_grouped = df.groupby('movie_title').agg(
            avg_rating=('movie_rating', 'mean'),
            num_ratings=('movie_rating', 'count')
        ).reset_index()
        df_filtered = df_grouped[df_grouped['num_ratings'] >= min_ratings]
        df_sorted = df_filtered.sort_values(['avg_rating', 'num_ratings'], ascending=False)
        return df_sorted.head(10)

    elif tipo == 'Por género':
        if genre == 'Todos':
            df = genre_popularity[genre_popularity['num_ratings'] >= min_ratings]
        else:
            df = genre_popularity[(genre_popularity['genre'] == genre) &
                                  (genre_popularity['num_ratings'] >= min_ratings)]
        df = df.sort_values(['avg_rating', 'num_ratings'], ascending=False)
        return df[['movie_title', 'avg_rating', 'num_ratings', 'genre']].head(10)

# Widgets
interact(
    recomendaciones_interactivas,
    tipo=Dropdown(options=['Popularidad', 'Por año', 'Por género'], description='Tipo:'),
    min_ratings=IntSlider(min=10, max=500, step=10, value=50, description='Mín. ratings'),
    year=IntSlider(min=1990, max=2020, step=1, value=2000, description='Año:'),
    genre=Dropdown(options=generos, description='Género:')
)