# -*- coding: utf-8 -*-
"""2. Modelo_1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rUqszKIMXGXHOJLg81KgYuECAQvznAfT

# <font color='056938'> **Librerias** </font>
"""

import os
import sys
import numpy as np
import pandas as pd
import sqlite3 as sql
import plotly.graph_objs as go ### para gráficos
import plotly.express as px
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from ipywidgets import interact ## para análisis interactivo
from sklearn import neighbors ### basado en contenido un solo producto consumido
import joblib
from sklearn.neighbors import NearestNeighbors

"""
# <font color='056938'> **Conexion con Drive** </font>"""

# Conexion con Drive
from google.colab import drive
drive.mount('/content/drive')

# Cambio de directorio de Trabajo

path = '/content/drive/MyDrive/Mod2/ANALITICA3'
os.chdir(path)
sys.path.append(path)

"""# <font color='056938'> **Cargar base de datos** </font>"""

conn=sql.connect('/content/drive/MyDrive/Mod2/ANALITICA3/data/db_movies')
cur=conn.cursor() ###para funciones que ejecutan sql en base de datos

### Verificar las tablas que hay disponibles
cur.execute("SELECT name FROM sqlite_master where type='table' ")
cur.fetchall()

# Cargas la tabla que ya contiene los datos procesados
tabla_completa = pd.read_sql_query("SELECT * FROM full_ratings", conn)

"""# <font color='056938'> **Tabla Completa con datos procesados** </font>"""

tabla_completa

"""**Recomendaciones basado en popularidad**

Se construye una tabla que mide la popularidad de las películas basada en las calificaciones otorgadas por los usuarios. Se filtran las películas que tienen un número de calificaciones comprendido entre 50 y 500, ya que este rango garantiza una cantidad suficiente de opiniones
"""

# Crear tabla de popularidad de películas
movie_popularity = pd.read_sql('''
    SELECT
        movie_title,
        COUNT(*) AS num_ratings,
        ROUND(AVG(movie_rating), 2) AS avg_rating
    FROM full_ratings
    GROUP BY movie_title
    HAVING num_ratings BETWEEN 50 AND 500
''', conn)

# Ordenar por promedio de calificación y número de votos
popular_movies = movie_popularity.sort_values(['avg_rating', 'num_ratings'], ascending=False)

# Mostrar top 10 películas recomendadas por popularidad
popular_movies.head(10)

"""En la tabla del top 10 de peliculas recomendadas se evidencian peliculas con numeros considerables de calificaciones y rating superiores a 4.24

**Fórmula del score ponderado**

Se implementa un  basado en un score ponderado, que combina tanto la calificación promedio como la cantidad de calificaciones que ha recibido cada película. Se aplica una fórmula que da más peso al promedio de calificaciones cuando una película tiene muchas valoraciones y más peso al promedio global cuando tiene pocas.
"""

# Promedio global de todas las calificaciones
C = pd.read_sql('SELECT AVG(movie_rating) FROM full_ratings', conn).iloc[0, 0]

movie_popularity2 = pd.read_sql('''
    SELECT
        movie_title AS title,
        movie_id,
        COUNT(*) AS num_ratings,
        ROUND(AVG(movie_rating), 2) AS avg_rating
    FROM full_ratings
    GROUP BY movie_id, movie_title
''', conn)

# Promedio global de todas las calificaciones
C = pd.read_sql('SELECT AVG(movie_rating) FROM full_ratings', conn).iloc[0, 0]

# Percentil 75 de la cantidad de votos
m = movie_popularity2['num_ratings'].quantile(0.75)

# Calcular el score ponderado
movie_popularity2['weighted_score'] = (
    (movie_popularity2['num_ratings'] / (movie_popularity2['num_ratings'] + m)) * movie_popularity2['avg_rating'] +
    (m / (movie_popularity2['num_ratings'] + m)) * C
)

movie_popularity2 = pd.read_sql('''
    SELECT
        movie_title AS title,
        movie_id,
        COUNT(*) AS num_ratings,
        ROUND(AVG(movie_rating), 2) AS avg_rating
    FROM full_ratings
    GROUP BY movie_id, movie_title
''', conn)

# Percentil 75 de la cantidad de votos
m = movie_popularity2['num_ratings'].quantile(0.75)

# Calcular el score ponderado
movie_popularity2['weighted_score'] = (
    (movie_popularity2['num_ratings'] / (movie_popularity2['num_ratings'] + m)) * movie_popularity2['avg_rating'] +
    (m / (movie_popularity2['num_ratings'] + m)) * C
)

# Ordenar por el score ponderado
movie_popularity_sorted = movie_popularity2.sort_values('weighted_score', ascending=False)

# Mostrar las top 10 películas recomendadas
movie_popularity_sorted[['title', 'weighted_score', 'num_ratings', 'avg_rating']].head(10)

"""Realizando un comparativo entre las dos tablas de top10 por ranking, se observa que "Shawshank Redemption" se mantiene como la película mejor valorada en ambos métodos, lo que refuerza su popularidad y calidad general. Esto indica que tiene tanto una calificación alta como un número considerable de votaciones. Algunas películas como "American History X" y "Goodfellas", que estaban muy arriba en la primera tabla por promedio simple, ya no aparecen en el top 10 del ranking ponderado. Esto sugiere que aunque tienen calificaciones altas, su número de votos es relativamente bajo.

**Recomendaciones basado en popularidad y el año de publicacion**

Se reliza una consulta que tiene como propósito identificar las películas mejor valoradas por año de publicación, para esto se modifico las tablas iniciales donde realizamos la separacion del año de la pelicula de la columna "movie_title" y se registran en una nueva columna llamada "movie_year".
"""

# Consulta para obtener las mejores calificaciones por año de publicación
best_rated_by_year = pd.read_sql("""
    SELECT
        movie_year,
        movie_title,
        AVG(CASE WHEN movie_rating = 0 THEN NULL ELSE movie_rating END) AS avg_rat,
        COUNT(CASE WHEN movie_rating = 0 THEN NULL ELSE movie_rating END) AS rat_numb,
        COUNT(*) AS read_num
    FROM full_ratings
    WHERE movie_rating <> 0
    GROUP BY movie_year, movie_title
    ORDER BY movie_year DESC, avg_rat DESC
    LIMIT 10
""", conn)

# Mostrar los resultados
best_rated_by_year

"""**Recomendaciones basado en popularidad y por género**

Esta consulta permite identificar las películas más populares dentro de cada género, basándose en el promedio de calificaciones recibidas por los usuarios
"""

query = '''
WITH exploded_genres AS (
    SELECT
        movie_title,
        movie_rating,
        TRIM(je.value) AS genre
    FROM full_ratings,
         json_each('["' || REPLACE(movie_genres, '|', '","') || '"]') AS je
)
SELECT
    genre,
    movie_title,
    COUNT(*) AS num_ratings,
    ROUND(AVG(movie_rating), 2) AS avg_rating
FROM exploded_genres
WHERE movie_rating <> 0
GROUP BY genre, movie_title
HAVING num_ratings >= 10
ORDER BY genre, avg_rating DESC
'''

genre_popularity = pd.read_sql(query, conn)

# Mostrar las top 5 películas por cada género
genre_popularity.groupby('genre').head(5)

"""# <font color='056938'> **Sistema de recomendaciones interectivo** </font>

Implementamos un sistema de recomendaciones de películas interactivo utilizando ipywidgets, permitiendo al usuario explorar las películas mejor valoradas según distintos criterios como el genero, el año de publicacion y por su popularidad.
"""

from ipywidgets import interact, Dropdown, IntSlider

# Lista de géneros más opción "Todos"
generos = ['Todos'] + sorted(genre_popularity['genre'].unique().tolist())

def recomendaciones_interactivas(tipo, min_ratings=50, year=2000, genre='Todos'):
    if tipo == 'Popularidad':
        df = movie_popularity[movie_popularity['num_ratings'] >= min_ratings]
        df = df.sort_values(['avg_rating', 'num_ratings'], ascending=False)
        return df[['movie_title', 'avg_rating', 'num_ratings']].head(10)

    elif tipo == 'Por año':
        df = tabla_completa[(tabla_completa['movie_year'] == year) &
                            (tabla_completa['movie_rating'] >= 0)]
        df_grouped = df.groupby('movie_title').agg(
            avg_rating=('movie_rating', 'mean'),
            num_ratings=('movie_rating', 'count')
        ).reset_index()
        df_filtered = df_grouped[df_grouped['num_ratings'] >= min_ratings]
        df_sorted = df_filtered.sort_values(['avg_rating', 'num_ratings'], ascending=False)
        return df_sorted.head(10)

    elif tipo == 'Por género':
        if genre == 'Todos':
            df = genre_popularity[genre_popularity['num_ratings'] >= min_ratings]
        else:
            df = genre_popularity[(genre_popularity['genre'] == genre) &
                                  (genre_popularity['num_ratings'] >= min_ratings)]
        df = df.sort_values(['avg_rating', 'num_ratings'], ascending=False)
        return df[['movie_title', 'avg_rating', 'num_ratings', 'genre']].head(10)

# Widgets
interact(
    recomendaciones_interactivas,
    tipo=Dropdown(options=['Popularidad', 'Por año', 'Por género'], description='Tipo:'),
    min_ratings=IntSlider(min=10, max=500, step=10, value=50, description='Mín. ratings'),
    year=IntSlider(min=1990, max=2020, step=1, value=2000, description='Año:'),
    genre=Dropdown(options=generos, description='Género:')
)